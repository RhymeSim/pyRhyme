#!/usr/bin/env python
from py_rhyme.visit import VisItAPI as Vis
import argparse
import sys, os, glob, re


DS = {
    'path': '',
    'ncycles': 0,
    'current_cycle': 0,
}


def set_current_cycle(n):
    if 0 >= n > DS['ncycles']:
        DS['current_cycle'] = n
    elif n < 0:
        DS['current_cycle'] = n + DS['ncycles']
    elif n > DS['ncycles']:
        DS['current_cycle'] = n - DS['ncycles']


def play(o, n):
    if len(str(n)) > 0:
        to_cycle = DS['current_cycle'] + int(n)
    else:
        to_cycle = DS['ncycles']

    for i in range(DS['current_cycle'], to_cycle):
        o.cycle(i)


MODES = {
    'x': { 'desc': 'Command mode', 'actions': {
        'q': { 'desc': 'quit', 'ex': 'xq',
            'run': lambda o, _: sys.exit(0)
        },
    }},
    'p': { 'desc': 'Plot mode', 'actions': {
        'd': { 'desc': 'draw', 'ex': 'pd',
            'run': lambda o, _: o.draw()
        },
        's': { 'desc': 'change scaling', 'ex': 'pslinear',
            'run': lambda o, s: o.change_scaling(str(s)),
            'after': lambda o, _: o.draw()
        },
        'v': { 'desc': 'change variable', 'ex': 'pvrho_u',
            'run': lambda o, v: o.change_variable(str(v)),
            'after': lambda o, _: o.draw()
        },
    }},
    's': { 'desc': 'Slice mode', 'actions': {
        'l': { 'desc': 'change layer (%)', 'ex': 'sl25',
            'run': lambda o, l: o.change_layer(int(l)),
            'after': lambda o, _: o.draw(),
        }
    }},
    't': { 'desc': 'Time mode', 'actions': {
        't': { 'desc': 'find snapshot with closes time', 'ex': 'tt16.5',
            'run': lambda o, t: o.time(float(t)),
        },
    }},
    'c': { 'desc': 'Cycle mode', 'actions': {
        'n': { 'desc': 'change cycle', 'ex': 'cn25',
            'run': lambda o, n: o.cycle(int(n)),
            'after': lambda o, n: set_current_cycle(int(n))
        },
        'j': { 'desc': 'previous cycle', 'ex': 'cj',
            'run': lambda o, _: o.prev_cycle(),
            'after': lambda o, n: set_current_cycle(DS['current_cycle'] - 1)
        },
        'k': { 'desc': 'next cycle', 'ex': 'ck',
            'run': lambda o, _: o.next_cycle(),
            'after': lambda o, n:  set_current_cycle(DS['current_cycle'] + 1)
        },
        'p': { 'desc': 'play', 'ex': 'cp, cp10',
            'run': lambda o, l: play(o, l),
            'after': lambda o, _: o.cycle(DS['current_cycle'])
        },
    }},
}


def handle_commands(v, ds_len):
    while True:
        command = str(sys.stdin.readline().replace('\n', ''))

        if len(command) < 2:
            print('Wrong command combination!', command)
            continue

        mode = command[0]
        action = command[1]
        value = command[2:] if len(command) > 2 else ''

        if mode not in MODES:
            print('Unknonw mode:', mode)
            continue

        if action not in MODES[mode]['actions']:
            print('Unknown action', action, 'in', mode, 'mode')
            continue

        if 'before' in MODES[mode]['actions'][action]:
            MODES[mode]['actions'][action]['before'](v, value)

        MODES[mode]['actions'][action]['run'](v, value)

        if 'after' in MODES[mode]['actions'][action]:
            MODES[mode]['actions'][action]['after'](v, value)

DS = {
    'path': '',
    'ncycles': 0,
    'current_cycle': 0,
}


def set_current_cycle(n):
    if 0 <= n < DS['ncycles']:
        DS['current_cycle'] = n
    elif n < 0:
        DS['current_cycle'] = n + DS['ncycles']
    elif n > DS['ncycles']:
        DS['current_cycle'] = n - DS['ncycles']


def play(o, n):
    if len(str(n)) > 0:
        to_cycle = DS['current_cycle'] + int(n)
    else:
        to_cycle = DS['ncycles']

    for i in range(DS['current_cycle'], to_cycle):
        o.cycle(i)


def handle_commands(v):
    while True:
        command = str(sys.stdin.readline().replace('\n', ''))

        if len(command) < 2:
            print('Unknown combination!', command)
            continue

        mode = command[0]
        action = command[1]
        value = command[2:] if len(command) > 2 else ''

        if mode not in MODES:
            print('Unknonw mode:', mode)
            continue

        if action not in MODES[mode]['actions']:
            print('Unknown action', action, 'in', mode, 'mode')
            continue

        if 'before' in MODES[mode]['actions'][action]:
            MODES[mode]['actions'][action]['before'](v, value)

        MODES[mode]['actions'][action]['run'](v, value)

        if 'after' in MODES[mode]['actions'][action]:
            MODES[mode]['actions'][action]['after'](v, value)


def main():
    parser = argparse.ArgumentParser(
        description='Plotting a slice of a given chombo file')

    parser.add_argument('chombo_path', help='Path to chombo file', type=str)

    parser.add_argument('--var', help='Pseudocolor plot variable', type=str, default='rho')
    parser.add_argument('-s', '--scaling', help='Pseudocolor plot scaling', choices=['linear', 'log'], type=str, default='log')
    parser.add_argument('--min', help='Pseudocolor minimum value', type=float, default=None)
    parser.add_argument('--max', help='Pseudocolor maximum value', type=float, default=None)
    parser.add_argument('-c', '--colortable', help='Pseudocolor colortable', type=str, default='RdYlBu')
    parser.add_argument('--invert', help='Inverting pseudocolor colortable', action='store_false')

    parser.add_argument('-a', '--axis', help='Slicing axis', choices=['x', 'y', 'z'], type=str, default='z')
    parser.add_argument('-p', '--percent', help='Slicing layer (percent)', type=int, default=50)

    args = parser.parse_args()
    axis_type = 'ZAxis' if args.axis == 'z' else ('YAxis' if args.axis == 'y' else 'XAxis')


    matches = re.findall('[0-9]{5}', args.chombo_path)

    if len(matches) < 1:
        DS['path'] = args.chombo_path
        DS['ncycles'] = 1
    else:
        DS['path'] = os.path.splitext(args.chombo_path.replace(matches[-1], '*'))[0]
        DS['ncycles'] = len(glob.glob(args.chombo_path.replace(matches[-1], '*')))


    v = Vis()
    v.open(DS['path'])
    v.pseudocolor(args.var, scaling=args.scaling, zmin=args.min, zmax=args.max,
        ct=args.colortable, invert_ct=args.invert)
    v.slice(origin_type='Percent', val=args.percent, axis_type=axis_type)
    v.draw()


    print('Combine following modes and actions to execute a command:')
    print(MODES.keys())
    for m in MODES.keys():
        print('%-8s: %s' % (m, MODES[m]['desc']))
        for c in MODES[m]['actions'].keys():
            print('-%-7s: %-40s e.g. %s' % (c, MODES[m]['actions'][c]['desc'], MODES[m]['actions'][c]['ex']))

    handle_commands(v)


if __name__ == '__main__':
    main()
